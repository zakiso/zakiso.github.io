<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例 - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="java collection">





    <meta name="description" content="java collection">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例">
<meta property="og:url" content="https://apppills.com/2012/02/13/java/collection/2012-02-13-collection-13-weakhashmap/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:description" content="java collection">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://apppills.com/media/pic/java/collection/collection13.jpg">
<meta property="og:updated_time" content="2017-04-21T11:54:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例">
<meta name="twitter:description" content="java collection">
<meta name="twitter:image" content="https://apppills.com/media/pic/java/collection/collection13.jpg">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            <div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc">
                <a class="navbar-item" title="Table of Contents">
                    <i class="fa fa-list"></i>
                </a>
                <div class="navbar-dropdown is-right">
                    
                    
                    
                    
                    <a class="navbar-item" href="#第1部分-WeakHashMap介绍">1&nbsp;&nbsp;<b>第1部分 WeakHashMap介绍</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第2部分-WeakHashMap数据结构">2&nbsp;&nbsp;<b>第2部分 WeakHashMap数据结构</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第3部分-WeakHashMap源码解析-基于JDK1-6-0-45">3&nbsp;&nbsp;<b>第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第4部分-WeakHashMap遍历方式">4&nbsp;&nbsp;<b>第4部分 WeakHashMap遍历方式</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#4-1-遍历WeakHashMap的键值对">4.1&nbsp;&nbsp;4.1 遍历WeakHashMap的键值对</a>
                    
                    
                    
                    <a class="navbar-item" href="#4-2-遍历WeakHashMap的键">4.2&nbsp;&nbsp;4.2 遍历WeakHashMap的键</a>
                    
                    
                    
                    <a class="navbar-item" href="#4-3-遍历WeakHashMap的值">4.3&nbsp;&nbsp;4.3 遍历WeakHashMap的值</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第5部分-WeakHashMap示例">5&nbsp;&nbsp;<b>第5部分 WeakHashMap示例</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#更多内容">6&nbsp;&nbsp;<b>更多内容</b></a>
                    
                </div>
            </div>
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-13T01:01:00.000Z" itemprop="datePublished">2月 13 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            39 分钟 read (About 5819 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这一章，我们对WeakHashMap进行学习。<br>我们先对WeakHashMap有个整体认识，然后再学习它的源码，最后再通过实例来学会使用WeakHashMap。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 WeakHashMap介绍</a><br><a href="#anchor2">第2部分 WeakHashMap数据结构</a><br><a href="#anchor3">第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 WeakHashMap遍历方式</a><br><a href="#anchor5">第5部分 WeakHashMap示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-WeakHashMap介绍"><a href="#第1部分-WeakHashMap介绍" class="headerlink" title="第1部分 WeakHashMap介绍"></a>第1部分 WeakHashMap介绍</h1><p><strong>WeakHashMap简介</strong></p>
<p>WeakHashMap 继承于AbstractMap，实现了Map接口。<br>和HashMap一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是null。<br>不过WeakHashMap的键是“弱键”。在 WeakHashMap 中，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。<br>这个“弱键”的原理呢？大致上就是，通过WeakReference和ReferenceQueue实现的。 WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。实现步骤是：<br>&nbsp;&nbsp;(01) 新建WeakHashMap，将“键值对”添加到WeakHashMap中。<br>&nbsp;&nbsp;&nbsp;&nbsp;实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。<br>&nbsp;&nbsp;(02) 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。<br>&nbsp;&nbsp;(03) 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。</p>
<p>这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。</p>
<p>和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。</p>
<p><strong>WeakHashMap的构造函数</strong></p>
<p>WeakHashMap共有4个构造函数,如下：</p>
<pre><code>// 默认构造函数。
WeakHashMap()

// 指定“容量大小”的构造函数
WeakHashMap(int capacity)

// 指定“容量大小”和“加载因子”的构造函数
WeakHashMap(int capacity, float loadFactor)

// 包含“子Map”的构造函数
WeakHashMap(Map&lt;? extends K, ? extends V&gt; map)</code></pre><p><strong>WeakHashMap的API</strong></p>
<pre><code>void                   clear()
Object                 clone()
boolean                containsKey(Object key)
boolean                containsValue(Object value)
Set&lt;Entry&lt;K, V&gt;&gt;       entrySet()
V                      get(Object key)
boolean                isEmpty()
Set&lt;K&gt;                 keySet()
V                      put(K key, V value)
void                   putAll(Map&lt;? extends K, ? extends V&gt; map)
V                      remove(Object key)
int                    size()
Collection&lt;V&gt;          values()</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-WeakHashMap数据结构"><a href="#第2部分-WeakHashMap数据结构" class="headerlink" title="第2部分 WeakHashMap数据结构"></a>第2部分 WeakHashMap数据结构</h1><p>WeakHashMap的继承关系如下</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractMap&lt;K, V&gt;
         ↳     java.util.WeakHashMap&lt;K, V&gt;</code></pre><p>WeakHashMap的声明</p>
<pre><code>public class WeakHashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt; {}</code></pre><p>WeakHashMap与Map关系如下图：</p>
<p><img src="/media/pic/java/collection/collection13.jpg" alt="img"></p>
<p>从图中可以看出：<br>(01) WeakHashMap继承于AbstractMap，并且实现了Map接口。<br>(02) WeakHashMap是哈希表，但是它的键是”弱键”。WeakHashMap中保护几个重要的成员变量：table, size, threshold, loadFactor, modCount, queue。<br>&nbsp;&nbsp;table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>&nbsp;&nbsp;size是Hashtable的大小，它是Hashtable保存的键值对的数量。<br>&nbsp;&nbsp;threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。<br>&nbsp;&nbsp;loadFactor就是加载因子。<br>&nbsp;&nbsp;modCount是用来实现fail-fast机制的<br>&nbsp;&nbsp;queue保存的是“已被GC清除”的“弱引用的键”。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-WeakHashMap源码解析-基于JDK1-6-0-45"><a href="#第3部分-WeakHashMap源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)"></a>第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)</h1><p>下面对WeakHashMap的源码进行说明</p>
<pre><code>package java.util;
import java.lang.ref.WeakReference;
import java.lang.ref.ReferenceQueue;

public class WeakHashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt; {

    // 默认的初始容量是16，必须是2的幂。
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）
    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    // 默认加载因子
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    // 存储数据的Entry数组，长度是2的幂。
    // WeakHashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表
    private Entry[] table;

    // WeakHashMap的大小，它是WeakHashMap保存的键值对的数量
    private int size;

    // WeakHashMap的阈值，用于判断是否需要调整WeakHashMap的容量（threshold = 容量*加载因子）
    private int threshold;

    // 加载因子实际大小
    private final float loadFactor;

    // queue保存的是“已被GC清除”的“弱引用的键”。
    // 弱引用和ReferenceQueue 是联合使用的：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中
    private final ReferenceQueue&lt;K&gt; queue = new ReferenceQueue&lt;K&gt;();

    // WeakHashMap被改变的次数
    private volatile int modCount;

    // 指定“容量大小”和“加载因子”的构造函数
    public WeakHashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Initial Capacity: &quot;+
                                               initialCapacity);
        // WeakHashMap的最大容量只能是MAXIMUM_CAPACITY
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;

        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal Load factor: &quot;+
                                               loadFactor);
        // 找出“大于initialCapacity”的最小的2的幂
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;
        // 创建Entry数组，用来保存数据
        table = new Entry[capacity];
        // 设置“加载因子”
        this.loadFactor = loadFactor;
        // 设置“WeakHashMap阈值”，当WeakHashMap中存储数据的数量达到threshold时，就需要将WeakHashMap的容量加倍。
        threshold = (int)(capacity * loadFactor);
    }

    // 指定“容量大小”的构造函数
    public WeakHashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    // 默认构造函数。
    public WeakHashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        threshold = (int)(DEFAULT_INITIAL_CAPACITY);
        table = new Entry[DEFAULT_INITIAL_CAPACITY];
    }

    // 包含“子Map”的构造函数
    public WeakHashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, 16),
             DEFAULT_LOAD_FACTOR);
        // 将m中的全部元素逐个添加到WeakHashMap中
        putAll(m);
    }

    // 键为null的mask值。
    // 因为WeakReference中允许“null的key”，若直接插入“null的key”，将其当作弱引用时，会被删除。
    // 因此，这里对于“key为null”的清空，都统一替换为“key为NULL_KEY”，“NULL_KEY”是“静态的final常量”。
    private static final Object NULL_KEY = new Object();

    // 对“null的key”进行特殊处理
    private static Object maskNull(Object key) {
        return (key == null ? NULL_KEY : key);
    }

    // 还原对“null的key”的特殊处理
    private static &lt;K&gt; K unmaskNull(Object key) {
        return (K) (key == NULL_KEY ? null : key);
    }

    // 判断“x”和“y”是否相等
    static boolean eq(Object x, Object y) {
        return x == y || x.equals(y);
    }

    // 返回索引值
    // h &amp; (length-1)保证返回值的小于length
    static int indexFor(int h, int length) {
        return h &amp; (length-1);
    }

    // 清空table中无用键值对。原理如下：
    // (01) 当WeakHashMap中某个“弱引用的key”由于没有再被引用而被GC收回时，
    //   被回收的“该弱引用key”也被会被添加到&quot;ReferenceQueue(queue)&quot;中。
    // (02) 当我们执行expungeStaleEntries时，
    //   就遍历&quot;ReferenceQueue(queue)&quot;中的所有key
    //   然后就在“WeakReference的table”中删除与“ReferenceQueue(queue)中key”对应的键值对
    private void expungeStaleEntries() {
        Entry&lt;K,V&gt; e;
        while ( (e = (Entry&lt;K,V&gt;) queue.poll()) != null) {
            int h = e.hash;
            int i = indexFor(h, table.length);

            Entry&lt;K,V&gt; prev = table[i];
            Entry&lt;K,V&gt; p = prev;
            while (p != null) {
                Entry&lt;K,V&gt; next = p.next;
                if (p == e) {
                    if (prev == e)
                        table[i] = next;
                    else
                        prev.next = next;
                    e.next = null;  // Help GC
                    e.value = null; //  &quot;   &quot;
                    size--;
                    break;
                }
                prev = p;
                p = next;
            }
        }
    }

    // 获取WeakHashMap的table(存放键值对的数组)
    private Entry[] getTable() {
        // 删除table中“已被GC回收的key对应的键值对”
        expungeStaleEntries();
        return table;
    }

    // 获取WeakHashMap的实际大小
    public int size() {
        if (size == 0)
            return 0;
        // 删除table中“已被GC回收的key对应的键值对”
        expungeStaleEntries();
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    // 获取key对应的value
    public V get(Object key) {
        Object k = maskNull(key);
        // 获取key的hash值。
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int index = indexFor(h, tab.length);
        Entry&lt;K,V&gt; e = tab[index];
        // 在“该hash值对应的链表”上查找“键值等于key”的元素
        while (e != null) {
            if (e.hash == h &amp;&amp; eq(k, e.get()))
                return e.value;
            e = e.next;
        }
        return null;
    }

    // WeakHashMap是否包含key
    public boolean containsKey(Object key) {
        return getEntry(key) != null;
    }

    // 返回“键为key”的键值对
    Entry&lt;K,V&gt; getEntry(Object key) {
        Object k = maskNull(key);
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int index = indexFor(h, tab.length);
        Entry&lt;K,V&gt; e = tab[index];
        while (e != null &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get())))
            e = e.next;
        return e;
    }

    // 将“key-value”添加到WeakHashMap中
    public V put(K key, V value) {
        K k = (K) maskNull(key);
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int i = indexFor(h, tab.length);

        for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
            if (h == e.hash &amp;&amp; eq(k, e.get())) {
                V oldValue = e.value;
                if (value != oldValue)
                    e.value = value;
                return oldValue;
            }
        }

        // 若“该key”对应的键值对不存在于WeakHashMap中，则将“key-value”添加到table中
        modCount++;
        Entry&lt;K,V&gt; e = tab[i];
        tab[i] = new Entry&lt;K,V&gt;(k, value, queue, h, e);
        if (++size &gt;= threshold)
            resize(tab.length * 2);
        return null;
    }

    // 重新调整WeakHashMap的大小，newCapacity是调整后的单位
    void resize(int newCapacity) {
        Entry[] oldTable = getTable();
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        // 新建一个newTable，将“旧的table”的全部元素添加到“新的newTable”中，
        // 然后，将“新的newTable”赋值给“旧的table”。
        Entry[] newTable = new Entry[newCapacity];
        transfer(oldTable, newTable);
        table = newTable;

        if (size &gt;= threshold / 2) {
            threshold = (int)(newCapacity * loadFactor);
        } else {
            // 删除table中“已被GC回收的key对应的键值对”
            expungeStaleEntries();
            transfer(newTable, oldTable);
            table = oldTable;
        }
    }

    // 将WeakHashMap中的全部元素都添加到newTable中
    private void transfer(Entry[] src, Entry[] dest) {
        for (int j = 0; j &lt; src.length; ++j) {
            Entry&lt;K,V&gt; e = src[j];
            src[j] = null;
            while (e != null) {
                Entry&lt;K,V&gt; next = e.next;
                Object key = e.get();
                if (key == null) {
                    e.next = null;  // Help GC
                    e.value = null; //  &quot;   &quot;
                    size--;
                } else {
                    int i = indexFor(e.hash, dest.length);
                    e.next = dest[i];
                    dest[i] = e;
                }
                e = next;
            }
        }
    }

    // 将&quot;m&quot;的全部元素都添加到WeakHashMap中
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        int numKeysToBeAdded = m.size();
        if (numKeysToBeAdded == 0)
            return;

        // 计算容量是否足够，
        // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。
        if (numKeysToBeAdded &gt; threshold) {
            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);
            if (targetCapacity &gt; MAXIMUM_CAPACITY)
                targetCapacity = MAXIMUM_CAPACITY;
            int newCapacity = table.length;
            while (newCapacity &lt; targetCapacity)
                newCapacity &lt;&lt;= 1;
            if (newCapacity &gt; table.length)
                resize(newCapacity);
        }

        // 将“m”中的元素逐个添加到WeakHashMap中。
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())
            put(e.getKey(), e.getValue());
    }

    // 删除“键为key”元素
    public V remove(Object key) {
        Object k = maskNull(key);
        // 获取哈希值。
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int i = indexFor(h, tab.length);
        Entry&lt;K,V&gt; prev = tab[i];
        Entry&lt;K,V&gt; e = prev;

        // 删除链表中“键为key”的元素
        // 本质是“删除单向链表中的节点”
        while (e != null) {
            Entry&lt;K,V&gt; next = e.next;
            if (h == e.hash &amp;&amp; eq(k, e.get())) {
                modCount++;
                size--;
                if (prev == e)
                    tab[i] = next;
                else
                    prev.next = next;
                return e.value;
            }
            prev = e;
            e = next;
        }

        return null;
    }

    // 删除“键值对”
    Entry&lt;K,V&gt; removeMapping(Object o) {
        if (!(o instanceof Map.Entry))
            return null;
        Entry[] tab = getTable();
        Map.Entry entry = (Map.Entry)o;
        Object k = maskNull(entry.getKey());
        int h = HashMap.hash(k.hashCode());
        int i = indexFor(h, tab.length);
        Entry&lt;K,V&gt; prev = tab[i];
        Entry&lt;K,V&gt; e = prev;

        // 删除链表中的“键值对e”
        // 本质是“删除单向链表中的节点”
        while (e != null) {
            Entry&lt;K,V&gt; next = e.next;
            if (h == e.hash &amp;&amp; e.equals(entry)) {
                modCount++;
                size--;
                if (prev == e)
                    tab[i] = next;
                else
                    prev.next = next;
                return e;
            }
            prev = e;
            e = next;
        }

        return null;
    }

    // 清空WeakHashMap，将所有的元素设为null
    public void clear() {
        while (queue.poll() != null)
            ;

        modCount++;
        Entry[] tab = table;
        for (int i = 0; i &lt; tab.length; ++i)
            tab[i] = null;
        size = 0;

        while (queue.poll() != null)
            ;
    }

    // 是否包含“值为value”的元素
    public boolean containsValue(Object value) {
        // 若“value为null”，则调用containsNullValue()查找
        if (value==null)
            return containsNullValue();

        // 若“value不为null”，则查找WeakHashMap中是否有值为value的节点。
        Entry[] tab = getTable();
        for (int i = tab.length ; i-- &gt; 0 ;)
            for (Entry e = tab[i] ; e != null ; e = e.next)
                if (value.equals(e.value))
                    return true;
        return false;
    }

    // 是否包含null值
    private boolean containsNullValue() {
        Entry[] tab = getTable();
        for (int i = tab.length ; i-- &gt; 0 ;)
            for (Entry e = tab[i] ; e != null ; e = e.next)
                if (e.value==null)
                    return true;
        return false;
    }

    // Entry是单向链表。
    // 它是 “WeakHashMap链式存储法”对应的链表。
    // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数
    private static class Entry&lt;K,V&gt; extends WeakReference&lt;K&gt; implements Map.Entry&lt;K,V&gt; {
        private V value;
        private final int hash;
        // 指向下一个节点
        private Entry&lt;K,V&gt; next;

        // 构造函数。
        Entry(K key, V value,
          ReferenceQueue&lt;K&gt; queue,
              int hash, Entry&lt;K,V&gt; next) {
            super(key, queue);
            this.value = value;
            this.hash  = hash;
            this.next  = next;
        }

        public K getKey() {
            return WeakHashMap.&lt;K&gt;unmaskNull(get());
        }

        public V getValue() {
            return value;
        }

        public V setValue(V newValue) {
        V oldValue = value;
            value = newValue;
            return oldValue;
        }

        // 判断两个Entry是否相等
        // 若两个Entry的“key”和“value”都相等，则返回true。
        // 否则，返回false
        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k1 = getKey();
            Object k2 = e.getKey();
            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
                Object v1 = getValue();
                Object v2 = e.getValue();
                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                    return true;
            }
            return false;
        }

        // 实现hashCode()
        public int hashCode() {
            Object k = getKey();
            Object v = getValue();
            return  ((k==null ? 0 : k.hashCode()) ^
                     (v==null ? 0 : v.hashCode()));
        }

        public String toString() {
            return getKey() + &quot;=&quot; + getValue();
        }
    }

    // HashIterator是WeakHashMap迭代器的抽象出来的父类，实现了公共了函数。
    // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。
    private abstract class HashIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        // 当前索引
        int index;
        // 当前元素
        Entry&lt;K,V&gt; entry = null;
        // 上一次返回元素
        Entry&lt;K,V&gt; lastReturned = null;
        // expectedModCount用于实现fast-fail机制。
        int expectedModCount = modCount;

        // 下一个键(强引用)
        Object nextKey = null;

        // 当前键(强引用)
        Object currentKey = null;

        // 构造函数
        HashIterator() {
            index = (size() != 0 ? table.length : 0);
        }

        // 是否存在下一个元素
        public boolean hasNext() {
            Entry[] t = table;

            // 一个Entry就是一个单向链表
            // 若该Entry的下一个节点不为空，就将next指向下一个节点;
            // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。
            while (nextKey == null) {
                Entry&lt;K,V&gt; e = entry;
                int i = index;
                while (e == null &amp;&amp; i &gt; 0)
                    e = t[--i];
                entry = e;
                index = i;
                if (e == null) {
                    currentKey = null;
                    return false;
                }
                nextKey = e.get(); // hold on to key in strong ref
                if (nextKey == null)
                    entry = entry.next;
            }
            return true;
        }

        // 获取下一个元素
        protected Entry&lt;K,V&gt; nextEntry() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            if (nextKey == null &amp;&amp; !hasNext())
                throw new NoSuchElementException();

            lastReturned = entry;
            entry = entry.next;
            currentKey = nextKey;
            nextKey = null;
            return lastReturned;
        }

        // 删除当前元素
        public void remove() {
            if (lastReturned == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();

            WeakHashMap.this.remove(currentKey);
            expectedModCount = modCount;
            lastReturned = null;
            currentKey = null;
        }

    }

    // value的迭代器
    private class ValueIterator extends HashIterator&lt;V&gt; {
        public V next() {
            return nextEntry().value;
        }
    }

    // key的迭代器
    private class KeyIterator extends HashIterator&lt;K&gt; {
        public K next() {
            return nextEntry().getKey();
        }
    }

    // Entry的迭代器
    private class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Map.Entry&lt;K,V&gt; next() {
            return nextEntry();
        }
    }

    // WeakHashMap的Entry对应的集合
    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;

    // 返回“key的集合”，实际上返回一个“KeySet对象”
    public Set&lt;K&gt; keySet() {
        Set&lt;K&gt; ks = keySet;
        return (ks != null ? ks : (keySet = new KeySet()));
    }

    // Key对应的集合
    // KeySet继承于AbstractSet，说明该集合中没有重复的Key。
    private class KeySet extends AbstractSet&lt;K&gt; {
        public Iterator&lt;K&gt; iterator() {
            return new KeyIterator();
        }

        public int size() {
            return WeakHashMap.this.size();
        }

        public boolean contains(Object o) {
            return containsKey(o);
        }

        public boolean remove(Object o) {
            if (containsKey(o)) {
                WeakHashMap.this.remove(o);
                return true;
            }
            else
                return false;
        }

        public void clear() {
            WeakHashMap.this.clear();
        }
    }

    // 返回“value集合”，实际上返回的是一个Values对象
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs = values;
        return (vs != null ?  vs : (values = new Values()));
    }

    // “value集合”
    // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，
    // Values中的元素能够重复。因为不同的key可以指向相同的value。
    private class Values extends AbstractCollection&lt;V&gt; {
        public Iterator&lt;V&gt; iterator() {
            return new ValueIterator();
        }

        public int size() {
            return WeakHashMap.this.size();
        }

        public boolean contains(Object o) {
            return containsValue(o);
        }

        public void clear() {
            WeakHashMap.this.clear();
        }
    }

    // 返回“WeakHashMap的Entry集合”
    // 它实际是返回一个EntrySet对象
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
        return es != null ? es : (entrySet = new EntrySet());
    }

    // EntrySet对应的集合
    // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。
    private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return new EntryIterator();
        }

        // 是否包含“值(o)”
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k = e.getKey();
            Entry candidate = getEntry(e.getKey());
            return candidate != null &amp;&amp; candidate.equals(e);
        }

        // 删除“值(o)”
        public boolean remove(Object o) {
            return removeMapping(o) != null;
        }

        // 返回WeakHashMap的大小
        public int size() {
            return WeakHashMap.this.size();
        }

        // 清空WeakHashMap
        public void clear() {
            WeakHashMap.this.clear();
        }

        // 拷贝函数。将WeakHashMap中的全部元素都拷贝到List中
        private List&lt;Map.Entry&lt;K,V&gt;&gt; deepCopy() {
            List&lt;Map.Entry&lt;K,V&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(size());
            for (Map.Entry&lt;K,V&gt; e : this)
                list.add(new AbstractMap.SimpleEntry&lt;K,V&gt;(e));
            return list;
        }

        // 返回Entry对应的Object[]数组
        public Object[] toArray() {
            return deepCopy().toArray();
        }

        // 返回Entry对应的T[]数组(T[]我们新建数组时，定义的数组类型)
        public &lt;T&gt; T[] toArray(T[] a) {
            return deepCopy().toArray(a);
        }
    }
}</code></pre><p>说明：WeakHashMap和HashMap都是通过”拉链法”实现的散列表。它们的源码绝大部分内容都一样，这里就只是对它们不同的部分就是说明。</p>
<p>WeakReference是“弱键”实现的哈希表。它这个“弱键”的目的就是：实现对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。<br>“弱键”是一个“弱引用(WeakReference)”，在Java中，WeakReference和ReferenceQueue 是联合使用的。在WeakHashMap中亦是如此：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 接着，WeakHashMap会根据“引用队列”，来删除“WeakHashMap中已被GC回收的‘弱键’对应的键值对”。<br>另外，理解上面思想的重点是通过 expungeStaleEntries() 函数去理解。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-WeakHashMap遍历方式"><a href="#第4部分-WeakHashMap遍历方式" class="headerlink" title="第4部分 WeakHashMap遍历方式"></a>第4部分 WeakHashMap遍历方式</h1><h2 id="4-1-遍历WeakHashMap的键值对"><a href="#4-1-遍历WeakHashMap的键值对" class="headerlink" title="4.1 遍历WeakHashMap的键值对"></a>4.1 遍历WeakHashMap的键值对</h2><p>第一步：根据entrySet()获取WeakHashMap的“键值对”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是WeakHashMap对象
// map中的key是String类型，value是Integer类型
Integer integ = null;
Iterator iter = map.entrySet().iterator();
while(iter.hasNext()) {
    Map.Entry entry = (Map.Entry)iter.next();
    // 获取key
    key = (String)entry.getKey();
        // 获取value
    integ = (Integer)entry.getValue();
}</code></pre><h2 id="4-2-遍历WeakHashMap的键"><a href="#4-2-遍历WeakHashMap的键" class="headerlink" title="4.2 遍历WeakHashMap的键"></a>4.2 遍历WeakHashMap的键</h2><p>第一步：根据keySet()获取WeakHashMap的“键”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是WeakHashMap对象
// map中的key是String类型，value是Integer类型
String key = null;
Integer integ = null;
Iterator iter = map.keySet().iterator();
while (iter.hasNext()) {
        // 获取key
    key = (String)iter.next();
        // 根据key，获取value
    integ = (Integer)map.get(key);
}</code></pre><h2 id="4-3-遍历WeakHashMap的值"><a href="#4-3-遍历WeakHashMap的值" class="headerlink" title="4.3 遍历WeakHashMap的值"></a>4.3 遍历WeakHashMap的值</h2><p>第一步：根据value()获取WeakHashMap的“值”的集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是WeakHashMap对象
// map中的key是String类型，value是Integer类型
Integer value = null;
Collection c = map.values();
Iterator iter= c.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}</code></pre><p>WeakHashMap遍历测试程序如下：</p>
<pre><code>import java.util.Map;
import java.util.Random;
import java.util.Iterator;
import java.util.WeakHashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Collection;

/*
 * @desc 遍历WeakHashMap的测试程序。
 *   (01) 通过entrySet()去遍历key、value，参考实现函数：
 *        iteratorHashMapByEntryset()
 *   (02) 通过keySet()去遍历key、value，参考实现函数：
 *        iteratorHashMapByKeyset()
 *   (03) 通过values()去遍历value，参考实现函数：
 *        iteratorHashMapJustValues()
 *
 * @author skywang
 */
public class WeakHashMapIteratorTest {

    public static void main(String[] args) {
        int val = 0;
        String key = null;
        Integer value = null;
        Random r = new Random();
        WeakHashMap map = new WeakHashMap();

        for (int i=0; i&lt;12; i++) {
            // 随机获取一个[0,100)之间的数字
            val = r.nextInt(100);

            key = String.valueOf(val);
            value = r.nextInt(5);
            // 添加到WeakHashMap中
            map.put(key, value);
            System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value);
        }
        // 通过entrySet()遍历WeakHashMap的key-value
        iteratorHashMapByEntryset(map) ;

        // 通过keySet()遍历WeakHashMap的key-value
        iteratorHashMapByKeyset(map) ;

        // 单单遍历WeakHashMap的value
        iteratorHashMapJustValues(map);        
    }

    /*
     * 通过entry set遍历WeakHashMap
     * 效率高!
     */
    private static void iteratorHashMapByEntryset(WeakHashMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator WeakHashMap By entryset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();

            key = (String)entry.getKey();
            integ = (Integer)entry.getValue();
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }

    /*
     * 通过keyset来遍历WeakHashMap
     * 效率低!
     */
    private static void iteratorHashMapByKeyset(WeakHashMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator WeakHashMap By keyset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.keySet().iterator();
        while (iter.hasNext()) {
            key = (String)iter.next();
            integ = (Integer)map.get(key);
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }


    /*
     * 遍历WeakHashMap的values
     */
    private static void iteratorHashMapJustValues(WeakHashMap map) {
        if (map == null)
            return ;

        Collection c = map.values();
        Iterator iter= c.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
       }
    }
}</code></pre><p><a name="anchor5"></a></p>
<h1 id="第5部分-WeakHashMap示例"><a href="#第5部分-WeakHashMap示例" class="headerlink" title="第5部分 WeakHashMap示例"></a>第5部分 WeakHashMap示例</h1><p>下面通过实例来学习如何使用WeakHashMap</p>
<pre><code>import java.util.Iterator;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.Date;
import java.lang.ref.WeakReference;

/**
 * @desc WeakHashMap测试程序
 *
 * @author skywang
 * @email kuiwu-wang@163.com
 */
public class WeakHashMapTest {

    public static void main(String[] args) throws Exception {
        testWeakHashMapAPIs();
    }

    private static void testWeakHashMapAPIs() {
        // 初始化3个“弱键”
        String w1 = new String(&quot;one&quot;);
        String w2 = new String(&quot;two&quot;);
        String w3 = new String(&quot;three&quot;);
        // 新建WeakHashMap
        Map wmap = new WeakHashMap();

        // 添加键值对
        wmap.put(w1, &quot;w1&quot;);
        wmap.put(w2, &quot;w2&quot;);
        wmap.put(w3, &quot;w3&quot;);

        // 打印出wmap
        System.out.printf(&quot;\nwmap:%s\n&quot;,wmap );

        // containsKey(Object key) :是否包含键key
        System.out.printf(&quot;contains key two : %s\n&quot;,wmap.containsKey(&quot;two&quot;));
        System.out.printf(&quot;contains key five : %s\n&quot;,wmap.containsKey(&quot;five&quot;));

        // containsValue(Object value) :是否包含值value
        System.out.printf(&quot;contains value 0 : %s\n&quot;,wmap.containsValue(new Integer(0)));

        // remove(Object key) ： 删除键key对应的键值对
        wmap.remove(&quot;three&quot;);

        System.out.printf(&quot;wmap: %s\n&quot;,wmap );



        // ---- 测试 WeakHashMap 的自动回收特性 ----

        // 将w1设置null。
        // 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对
        w1 = null;
        // 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对
        System.gc();

        // 遍历WeakHashMap
        Iterator iter = wmap.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry en = (Map.Entry)iter.next();
            System.out.printf(&quot;next : %s - %s\n&quot;,en.getKey(),en.getValue());
        }
        // 打印WeakHashMap的实际大小
        System.out.printf(&quot; after gc WeakHashMap size:%s\n&quot;, wmap.size());
    }
}</code></pre><p>运行结果： </p>
<pre><code>wmap:{three=w3, one=w1, two=w2}
contains key two : true
contains key five : false
contains value 0 : false
wmap: {one=w1, two=w2}
next : two - w2
after gc WeakHashMap size:1</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/java/">#java</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2012/02/14/java/collection/2012-02-14-collection-14-mapsummary/">Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2012/02/12/java/collection/2012-02-12-collection-12-treemap/">Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>